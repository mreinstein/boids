<!doctype html>
<html>
<head>
    <title>Boids Seek + Obstacle Avoidance Example</title>
    <meta name=theme-color content=#303F9F><meta name=viewport content="width=device-width,minimum-scale=1">
    <style>
        body {
          font-family: monospace;
          background-color: white;
          text-align: center;
          padding: 60px 0px;
        }

        canvas {
            padding: 0px;
            border:  1px solid #cacaca;
        }

    </style>
</head>
<body>

<h1>Seek + Obstacle Avoidance</h1>
<canvas width="400" height="240"></canvas>

<script type="module">
import * as Boids  from '../src/steering-vehicle.js'
import * as Common from './common.js'
import { vec2 }    from 'https://cdn.skypack.dev/pin/gl-matrix@v3.4.3-OSmwlRYK5GW1unkuAQkN/mode=imports,min/optimized/gl-matrix.js'
import randomInt   from 'https://cdn.jsdelivr.net/gh/mreinstein/random-gap/int.js'


function animate (t) {
    const dt = (t - (last || t)) / 1000
    last = t

    for (const boid of neighbors) {
        if (vec2.distance(target, boid.transform.position) > 8) {
            vec2.set(arrivalForce, 0, 0)
            Boids.steerForSeek(arrivalForce, boid, target)

            const arrivalWeight = 1
            vec2.scale(arrivalForce, arrivalForce, arrivalWeight)

            vec2.set(separationForce, 0, 0)
            Boids.steerForCollisionAvoidance(separationForce, boid, neighbors)

            const separationWeight = 5
            vec2.scale(separationForce, separationForce, separationWeight)
            vec2.add(arrivalForce, arrivalForce, separationForce)
            
            Boids.applySteeringForce(boid, arrivalForce, dt)
            // update rotation to match boid's heading
            boid.transform.rotation = Math.atan2(boid.rigidBody.velocity[1], boid.rigidBody.velocity[0])
        }

        // Euler integrate (per frame) velocity into position
        vec2.add(boid.transform.position, boid.transform.position, boid.rigidBody.velocity)

        // TODO: remove this one line after debugging
        //break
    }

    context.clearRect(0, 0, canvas.width, canvas.height)

    Common.drawTarget(target, context)
    let i = 0
    for (const b of neighbors) {
        Common.drawBoid(b, context, i === 0 ? 'boid' : 'circle')
        i++
    }

    requestAnimationFrame(animate)
}


const canvas = document.querySelector('canvas')
const context = canvas.getContext('2d')

let last = 0

const arrivalForce = [ 0, 0 ]
const separationForce = [ 0, 0 ]
const wanderForce = [ 0, 0 ]

const boidCount = 8
const neighbors = [ ]

for (let i=0; i < boidCount; i++)
    neighbors.push(Common.createBoid({ x: randomInt(50,350), y: randomInt(0,200), maxForce: 60, radius: 8, maxSeeAhead: 60 }))

//neighbors[1].aabb.position[0] = 200
//neighbors[1].aabb.position[1] = 120


const target = [ 0, 0 ]

canvas.addEventListener('mousemove', function (ev) {
    vec2.set(target, ev.offsetX, ev.offsetY)
}, { passive: true })

requestAnimationFrame(animate)

</script>

</body>
</html>