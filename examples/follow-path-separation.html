<!doctype html>
<html>
<head>
    <title>Boids Follow Path + Separation Example</title>
    <meta name=theme-color content=#303F9F><meta name=viewport content="width=device-width,minimum-scale=1">
    <style>
        body {
          font-family: monospace;
          background-color: white;
          text-align: center;
          padding: 60px 0px;
        }

        canvas {
            padding: 0px;
            border:  1px solid #cacaca;
        }

    </style>
</head>
<body>

<h1>Follow Path + Separation</h1>
<canvas width="400" height="240"></canvas>

<script type="module">
import * as Boids    from '../src/steering-arcade.js'
import * as Common   from './common.js'
import PolylinePath  from '../src/polyline-path.js'
import { vec2 }      from 'https://cdn.skypack.dev/pin/gl-matrix@v3.4.3-OSmwlRYK5GW1unkuAQkN/mode=imports,min/optimized/gl-matrix.js'
import segmentNormal from 'https://cdn.jsdelivr.net/gh/mreinstein/collision-2d/src/segment-normal.js'
import randomInt     from 'https://cdn.jsdelivr.net/gh/mreinstein/random-gap/int.js'


function animate (t) {
    const dt = (t - (last || t)) / 1000
    last = t

    for (const boid of neighbors) {
        vec2.set(followPathForce, 0, 0)
        const direction = 1
        const predictionTime = dt
        const loop = false
        Boids.steerForFollowPath(followPathForce, boid, p, direction, predictionTime, loop)


        const followPathWeight = 2.0
        vec2.scale(followPathForce, followPathForce, followPathWeight)

        vec2.set(separationForce, 0, 0)
        const maxDistance = 180
        const fieldOfViewDegrees = 135
        const minDistance = boid.steering.radius * 3
        Boids.steerForSeparation(separationForce, boid, minDistance, maxDistance, fieldOfViewDegrees, neighbors)

        const separationWeight = 6.0
        vec2.scale(separationForce, separationForce, separationWeight)
        vec2.add(followPathForce, followPathForce, separationForce)
        
        Boids.applySteeringForce(boid, followPathForce, dt)

        // Euler integrate (per frame) velocity into position
        boid.transform.position[0] += (boid.rigidBody.velocity[0] * dt)
        boid.transform.position[1] += (boid.rigidBody.velocity[1] * dt)

        // update rotation to match boid's heading
        boid.transform.rotation = Math.atan2(boid.rigidBody.velocity[1], boid.rigidBody.velocity[0])
    }

    context.clearRect(0, 0, canvas.width, canvas.height)

    Common.drawPathTube(p, canvas, context)
    Common.drawPath(p, canvas, context)

    for (const b of neighbors)
        Common.drawBoid(b, context)

    requestAnimationFrame(animate)
}


const canvas = document.querySelector('canvas')
const context = canvas.getContext('2d')

const p = PolylinePath.create({
    cyclic: false,
    radius: 24,
    points: [
        [ 51, 111 ],
        [ 113, 174 ],
        [ 211, 61 ],
        [ 268, 108 ],
        [ 321, 65 ],
        [ 379, 69 ]
    ], 
    pointCount: 6
})

let last = 0

const followPathForce = [ 0, 0 ]
const separationForce = [ 0, 0 ]
const wanderForce = [ 0, 0 ]

const boidCount = 8
const neighbors = [ ]

for (let i=0; i < boidCount; i++)
    neighbors.push(Common.createBoid({ x: randomInt(45,55), y: randomInt(105,115), maxSpeed: 120, maxForce: 60, radius: 8 }))

requestAnimationFrame(animate)

</script>

</body>
</html>